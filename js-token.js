const TAG_JS=1,TAG_JSNonExpressionParen=2,TAG_InterpolationInTemplate=3,
	TYPE_StringLiteral=1,TYPE_NoSubstitutionTemplate=2,TYPE_TemplateHead=3,TYPE_TemplateMiddle=4,TYPE_TemplateTail=5,TYPE_RegularExpressionLiteral=6,TYPE_MultiLineComment=7,TYPE_SingleLineComment=8,TYPE_IdentifierName=9,TYPE_NumericLiteral=10,TYPE_Punctuator=11,TYPE_WhiteSpace=12,TYPE_LineTerminatorSequence=13,TYPE_Invalid=14,
	TOK_ExpressionBraceEnd="?A",TOK_PostfixIncDec="?B",TOK_UnaryIncDec="?C",TOK_InterpolationInTemplate="?D",TOK_NoLineTerminatorHere="?E",TOK_NonExpressionParenEnd="?F",TOK_NonExpressionParenKeyword="?G";
	RegularExpressionLiteral=/\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu,
	Punctuator=/--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y,
	IdentifierName=/(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu,
	StringLiteral=/(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y,
	NumericLiteral=/(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y,
	Template=/[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y,
	WhiteSpace=/[	\v\f\ufeff\p{Zs}]+/yu,
	LineTerminatorSequence=/\r?\n|[\r\u2028\u2029]/y,
	MultiLineComment=/\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y,
	SingleLineComment=/\/\/.*/y,
// TOK_InterpolationInTemplate,TOK_NoLineTerminatorHere,TOK_NonExpressionParenEnd,TOK_UnaryIncDec
	TokensPrecedingExpression=/^(?:[\/+-]|\.{3}|\?[C-F])?$|[{}([,;<>=*%&|^!~?:]$/,
// TOK_NoLineTerminatorHere,TOK_NonExpressionParenEnd
	TokensNotPrecedingObjectLiteral=/^(?:=>|[;\]){}]|else|\?[EF])?$/,
	KeywordsWithExpressionAfter=/^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/,
	KeywordsWithNoLineTerminatorAfter=/^(?:return|throw|yield)$/,
	Newline=RegExp(LineTerminatorSequence.source);

function*jsTokens(A){
	for(var braces=[],firstCodePoint,isExpression,lastIndex=0,lastSignificantToken="",length=A.length,match,mode,nextLastIndex,nextLastSignificantToken,parenNesting=0,postfixIncDec,punctuator,S=[{tag:TAG_JS}],p=0;lastIndex<length;){
		mode=S[p];
		switch(mode.tag){
			case TAG_JS:
			case TAG_JSNonExpressionParen:
			case TAG_InterpolationInTemplate:
				if(A[lastIndex]==="/"&&(TokensPrecedingExpression.test(lastSignificantToken)||KeywordsWithExpressionAfter.test(lastSignificantToken))){
					RegularExpressionLiteral.lastIndex=lastIndex;
					if(match=RegularExpressionLiteral.exec(A)){
						lastIndex=RegularExpressionLiteral.lastIndex;
						lastSignificantToken=match[0];
						postfixIncDec=true;
						yield({
							type:TYPE_RegularExpressionLiteral,
							value:match[0],
							closed:match[1]!==void 0&&match[1]!=="\\"
						});
						continue
					}
				}
				Punctuator.lastIndex=lastIndex;
				if(match=Punctuator.exec(A)){
					punctuator=match[0];
					nextLastIndex=Punctuator.lastIndex;
					nextLastSignificantToken=punctuator;
					switch(punctuator){
						case"(":
							if(lastSignificantToken===TOK_NonExpressionParenKeyword)
								S[++p]={tag:TAG_JSNonExpressionParen,nesting:parenNesting};
							parenNesting++;
							postfixIncDec=false;
							break;
						case")":
							parenNesting--;
							postfixIncDec=true;
							if(mode.tag===TAG_JSNonExpressionParen&&parenNesting===mode.nesting)
								nextLastSignificantToken=TOK_NonExpressionParenEnd,
								--p,postfixIncDec=false;
							break;
						case"{":
							Punctuator.lastIndex=0;
							isExpression=!TokensNotPrecedingObjectLiteral.test(lastSignificantToken)&&(TokensPrecedingExpression.test(lastSignificantToken)||KeywordsWithExpressionAfter.test(lastSignificantToken));
							braces.push(isExpression);
							postfixIncDec=false;
							break;
						case"}":
							if(mode.tag===TAG_InterpolationInTemplate&&braces.length===mode.nesting){
								Template.lastIndex=lastIndex;
								match=Template.exec(A);
								lastIndex=Template.lastIndex;
								lastSignificantToken=match[0];
								if(match[1]==="${"){
									lastSignificantToken=TOK_InterpolationInTemplate;
									postfixIncDec=false;
									yield({
										type:TYPE_TemplateMiddle,
										value:match[0]
									})
								}else{
									--p,postfixIncDec=true;
									yield({
										type:TYPE_TemplateTail,
										value:match[0],
										closed:match[1]==="`"
									})
								}
								continue
							}
							postfixIncDec=braces.pop();
							nextLastSignificantToken=postfixIncDec?TOK_ExpressionBraceEnd:"}";
							break;
						case"]":
							postfixIncDec=true;
							break;
						case"++":case"--":
							nextLastSignificantToken=postfixIncDec?TOK_PostfixIncDec:TOK_UnaryIncDec;
							break;
						case"<":
							postfixIncDec=false;
							break;
						default:
							postfixIncDec=false;
					}
					lastIndex=nextLastIndex;
					lastSignificantToken=nextLastSignificantToken;
					yield({type:TYPE_Punctuator,value:punctuator});
					continue
				}
				IdentifierName.lastIndex=lastIndex;
				if(match=IdentifierName.exec(A)){
					lastIndex=IdentifierName.lastIndex;
					switch(nextLastSignificantToken=match[0]){
						case"for":case"if":case"while":case"with":
							if(lastSignificantToken!=="."&&lastSignificantToken!=="?.")
								nextLastSignificantToken=TOK_NonExpressionParenKeyword
					}
					lastSignificantToken=nextLastSignificantToken;
					postfixIncDec=!KeywordsWithExpressionAfter.test(match[0]);
					yield({type:TYPE_IdentifierName,value:match[0]});
					continue
				}
				StringLiteral.lastIndex=lastIndex;
				if(match=StringLiteral.exec(A)){
					lastIndex=StringLiteral.lastIndex;
					lastSignificantToken=match[0];
					postfixIncDec=true;
					yield({
						type:TYPE_StringLiteral,
						value:match[0],
						closed:match[2]!==void 0
					});
					continue
				}
				NumericLiteral.lastIndex=lastIndex;
				if(match=NumericLiteral.exec(A)){
					lastIndex=NumericLiteral.lastIndex;
					lastSignificantToken=match[0];
					postfixIncDec=true;
					yield({
						type:TYPE_NumericLiteral,
						value:match[0]
					});
					continue
				}
				Template.lastIndex=lastIndex;
				if(match=Template.exec(A)){
					lastIndex=Template.lastIndex;
					lastSignificantToken=match[0];
					if(match[1]==="${"){
						lastSignificantToken=TOK_InterpolationInTemplate;
						S[++p]={tag:TAG_InterpolationInTemplate,nesting:braces.length};
						postfixIncDec=false;
						yield({
							type:TYPE_TemplateHead,
							value:match[0]
						})
					}else{
						postfixIncDec=true;
						yield({
							type:TYPE_NoSubstitutionTemplate,
							value:match[0],
							closed:match[1]==="`"
						})
					}
					continue
				}
				break
		}
		WhiteSpace.lastIndex=lastIndex;
		if(match=WhiteSpace.exec(A)){
			lastIndex=WhiteSpace.lastIndex;
			yield({
				type:TYPE_WhiteSpace,
				value:match[0]
			});
			continue
		}
		LineTerminatorSequence.lastIndex=lastIndex;
		if(match=LineTerminatorSequence.exec(A)){
			lastIndex=LineTerminatorSequence.lastIndex;
			postfixIncDec=false;
			if(KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)){
				lastSignificantToken=TOK_NoLineTerminatorHere;
			}
			yield({
				type:TYPE_LineTerminatorSequence,
				value:match[0]
			});
			continue
		}
		MultiLineComment.lastIndex=lastIndex;
		if(match=MultiLineComment.exec(A)){
			lastIndex=MultiLineComment.lastIndex;
			if(Newline.test(match[0])){
				postfixIncDec=false;
				if(KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)){
					lastSignificantToken=TOK_NoLineTerminatorHere;
				}
			}
			yield({
				type:TYPE_MultiLineComment,
				value:match[0],
				closed:match[1]!==void 0
			});
			continue
		}
		SingleLineComment.lastIndex=lastIndex;
		if(match=SingleLineComment.exec(A)){
			lastIndex=SingleLineComment.lastIndex;
			postfixIncDec=false;
			yield({
				type:TYPE_SingleLineComment,
				value:match[0]
			});
			continue
		}
		firstCodePoint=String.fromCodePoint(A.codePointAt(lastIndex));
		lastIndex+=firstCodePoint.length;
		lastSignificantToken=firstCodePoint;
		postfixIncDec=false;
		yield({
			type:TYPE_Invalid,
			value:firstCodePoint
		})
	}
}